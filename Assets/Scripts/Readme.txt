*** Задание 1 *** 

- Кто такие программисты?
В широком смысле, те кто пишут программы или программируют. В узком смысле программист программисту рознь. 
От верстки сайтов до правки G-кода на станках с ЧПУ. 
От задания игровой логики до машинного обучения. 
От настройки UI до клиент-серверного взаимодействия.    

- Что должен уметь/знать программист?
Знать инструменты и язык, которыми пользуется. Знать, где искать достоверные ответы на появившиеся вопросы. 
Разбираться в чужом и своём старом коде. Читать мысли заказчика, геймдизайнера и составлять по ним ТЗ. Тестировать код.
Писать код, который реализует необходимое поведение. Проводить профилирование приложения. Оценивать трудоемкость работы. 

- Как вы считаете, чем будете заниматься на работе.
Читать чужой код. Верстать UI. Править и создавать баги. Внедрять новый функционал в приложении. Проверять, что ничего 
старое не отвалилось от новых правок.  

*** Задание 2 ***

- Зачем нужны интерфейсы и их отличие от классов
Интерфейс это договор о том какими свойствами и методами обязан обладать объект. Интерфейс абстрактный, поэтому 
конкретная реализация свойств и методов лежит на каждом классе. В интерфейсе не может быть полей.
Позволяет обращаться к объектом реализующим интерфейс не обращая внимания к каким именно классам они относятся.
Позволяется легко подменять одного исполнителя другим. 

- Зачем нужны обобщения и привести несколько примеров их использования
Позволяет использовать различные типы объектов в параметрах метода, вместо конкретных. 
Иначе в такой ситуации на пришлось бы делать множество перегрузок метода, которые принимали бы все комбинации 
входных значений. 
Например, метод который считает длину вектора и может принимать двумерные, трехмерные и так далее векторы.
Или какой-то буфер может хранить те типы объектов, которые задали при инициализации. При этом один и тот же код
будет работать с разными типами данных.       
 
 *** Задание 3 ***
 
 Шкала здоровья игрока обновляется по событию изменения здоровья.
 Эксепшен кидается если не настроен префаб HealthUI.     
 
 - Зачем нужно отлавливать исключения. Привести примеры
 Исключения отлавливаем, чтобы обозначить недопустимое поведение. Например, входные данные должны быть, а вместо них
 null. Или через индексатор пытаются обратиться к несуществующему элементу массива. Или не кто-то забыл настроить
 компоненты в редакторе Unity.
 В этих случаях передаем соответствующий эксепшен, чтобы показать разработчику об ошибке как можно ближе к точке ее 
 возникновения. Иначе недопустимые данные могут всплыть непонятно где и сильно усложнить отладку. 
 
 
 *** Задание 5 ***
 
 Расписать в текстовом документе плюсы и минусы изученных структур данных и 
 расписать примеры в которых нужно будет использовать тот или иной контейнер
 
 У необобщенных коллекций плюсом явялется то, что они могут содержать данные разных типов. 
 Минус, что надо приводить данные к конкретным типам.
 
 У обощенных коллекций, в плюс идет типовая безопасность.
 Дальше у разных коллекций есть свои достоинства и недостатки, связанные со сложностью операций добавления/удаления 
 в коллекцию, поиска в коллекции и перебора элементов коллекции.
  
 Очередь Queue и стэк Stack хороши когда мы добавляем и удаляем элементы с "правильной" стороны, но нам не требуется
 работать с серединой этого списка. Например, это могут быть сообщения в чате, стэк открытых окон.
 
 LinkedList можно применить для перемещения по вкладкам интерфейса. Так как знаем, где находимся сейчас и куда двинуть
 влево-вправо.
 
 Dictionary для хранения пользователей по id. Когда нам не важна последовательность хранения, но часто нужен доступ к 
 конкретным членам коллекции.
 
 ObservableCollection<T> если хотим получать информацию о происходящих в коллекции изменениях. Например, храним там 
 баффы игрока и рассылаем события о том что они начались, закончились и так далее.
 
 Видимо List подходит для все остальных случаев=)    
  